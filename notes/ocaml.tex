\documentclass[main.tex]{subfiles}
\begin{document}

\chapter{OCaml}
\epigraph{We will do so much Ocaml, you could call it Ocamlot}{Cleff}

This is another programming language chapter so it has two (2) main things: talk about some properties that the OCaml programming language has and the syntax the language has. If you want to code along, all you need is a working version of OCaml and a text editor. You can check to see if you have OCaml installed by running \texttt{ocaml --version}. At the time of writing, I am using Ruby 4.14.0. 
\texttt{ocaml} is repl which you can use to play around with OCaml but please use \texttt{utop}. It's a wrapper for \texttt{ocaml} and is much easier to use.  

\section{Introduction}

OCaml will probably look (and act) unlike any other language you have come across in the CS department up to this point. This is due to one key difference: OCaml supports both declarative and imperative programming. We will talk about this all in the next section, but for now let's just write our very first program.

\begin{lstlisting}[style=MyOcamlStyle]
(* helloWorld.ml *)
print_string "hello world"
\end{lstlisting}
Despite this being very simple, we observed five (5) things.
\begin{itemize}
    \item Comments are surrounded by \texttt{(* ... *)}
    \item no semicolons to denote end of statement$^*$
    \item \texttt{print\_string} is used to print things out to stdout
    \item Parenthesis are optional when calling functions$^*$ 
    \item OCaml file name conventions are \texttt{camlCase.ml}
    \item Strings exists in the language (most languages do, but some do not)
\end{itemize}
Now you may have noticed the $*$ symbol over point 2 and 4. That is because these observations are actually False. Or at least, not entirely true. For now though, let's just roll with it. 
In order to have the above code run, you can run
\begin{lstlisting}[]
ocamlc helloWorld.ml
./a.out
\end{lstlisting}
Congrats, you have just made your first program in OCaml!
There are some things to note however: 
\begin{itemize}
    \item OCaml is a compiled Language
    \item \texttt{ocamlc} is the ocaml compiler (some compilers like to take the name of the language and add 'c' to the end: javac, ocamlc, rustc"). 
    \item If you run an \texttt{ls} you will notice that along with the executable \texttt{a.out}, two other files were generated as well, \texttt{helloWorld.cmo} and \texttt{helloWorld.cmi}. The \texttt{.cmo} is the object file and can be thought of as analogous to the \texttt{.o} file generated by gcc. The \texttt{cmi} file is the interface file and can be thought of as analogous a compiled down \texttt{.h} file in c. 
    \item \texttt{ocamlc} is wrapped in a nice program called \texttt{dune}. \texttt{dune} will allow you to compile, run, and test your OCaml programs without much overhead. We use \texttt{dune} to help manage your projects. 
\end{itemize}

\section{Functional Programming}

According to Wikipedia, "functional programming is a programming paradigm where programs are constructed by applying and composing functions". This probably means nothing to you, so let's make our own definition. First let's define a few words, or rather one in particular: paradigm. Depending on the field, it has many different definitions. I want to not the lingustic's definitions, despite that is the one used here. I want to take the more general one: a set of thoughts and concepts related to a topic. With this defintion, I will say this: \textbf{Functional programming is a way of programming that focuses on creating functions rather than listing out steps to solve a problem.}. I'm sure that many people will disagree and dislike this definition but oh well. 

\subsection{Declarative Languages}
Functional languages are typically described as declarative. This means that values are declared and the focus is declaring \textbf{what} a solution is, rather than describing \textbf{how} a solution is reached. 
To see this let's do a real quick comparison in English for a process that finds even numbers in a list
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
        \begin{lstlisting}[]
    Imperative
+ make an empty list called results
+ Look at each item in the list
+ Divide the item by 2 and look at the remainder
+ if the remainder is 0, add the value to the results list
+ return the results list after you looked at all list items
       \end{lstlisting} & \hspace{1cm} & 
        \begin{lstlisting}[]
    Declarative
+ Take all the values that are even divisible by 2 from the list
+ Return those values
        \end{lstlisting} \\
    \end{tabular}
\end{table}

Notice that the imperative instructions tell you \textit{how} to do something and does so in steps. The declarative instructions tells you what you are looking for and assumes you can just figure out how to do it. If we translate the imperative code to ruby we get something like
\begin{lstlisting}[style=Myrubystyle]
#imperative.rb
results = []
arr.each{|item|
    remainder = item % 2
    if remainder == 0
        results.push(0)
    end
}
results
\end{lstlisting}
Now we haven't learned enough (or really any) OCaml at this point to write a solution to this yet\footnote{
If you wanted a solution here is one:\\
\texttt{let even lst = match lst with []-> []|h::t -> if h mod 2 == 0 then h::(even t) else (even t) in even lst}
}
, but let's look at a declariative python example:
\begin{lstlisting}[style=Myrubystyle]
#declarative.py
results = [x for x in arr if x % 2 == 0] 
\end{lstlisting}
Here, we don't tell python \textit{how} to solve the problem, we tell it what we want and python figures out the rest. 

\subsection{Side effects and Immutability}
One thing that functional programming aims to do is to minimize this idea of a side affect. Consider the following Ruby Code:
\begin{lstlisting}[style=Myrubystyle]
# side_effects.rb
@count = 0
def f(node)
  node.data = @count
  @count+=1
  @count
end
\end{lstlisting}
Functional programming wants to treat functions as, well, a function. This means that something like the following should be true:
\begin{lstlisting}
f(x) + f(x) + f(x) = 3 * f(x)
\end{lstlisting}
However, if we run the code above, then \texttt{f(x) + f(x) + f(x) = 1 + 2 + 3} and \texttt{3 * f(x) = 3 * 1}. This unpredictability is called a side effect (The true definition of a side effect is when non local variables get modified). 
When side effects occur, it becomes harder to reason and predict the behaviour of code (which means more bugs!).
To combat this, OCaml makes all variables immutable to help maintain \textbf{referential transparency}. Referentail transparency is the ability to replace an expression or a function with it's value and still obtain the same output. To simplify, OCaml wants to minimize the amount of outside contact your code has to make everything self contained. The more you rely on outside information or context, the more complicated your code becomes. Now we need to address the question, "What is an expression or function's value?"

\subsection{Expressions and Values}
In functional languages, one of the core ideas is ability to treat functions as data. Which means much like Ruby Procs, we can pass them in as arguments, or use them as return values in methods. But we are getting a little ahead of ourselves. Let's first see what data is in OCaml. 

In OCaml, we say that almost everything is an expression. Expressions are things like \texttt{4 + 3} or \texttt{2.3 < 1.5}.
We say that expressions evaluate to values. A value is something like \texttt{7} or \texttt{false}. All values are expressions in and of themselves, but not all expressions are values. Like a square and rectangle situation. All expressions also have a (data) type. The expression \texttt{3+4} evaluates to \texttt{7} so we say that both expressions have type \texttt{int}.
For the purpose of these notes I will use $e$ to represent an expression, $t$ for type, and the structure $e:t$ to say that the expression $e$ evaluates to type $t$. Consider the following:
\begin{lstlisting}[style=Myocamlstyle]
(* expressions.ml *)
true (* is a value, has type bool *)
3 * 4 (* is an expression, has type int *)
"hello" ^ "world" (* is an expression of type string *)
5.4 (* a value of type float *)
\end{lstlisting}
Now, we said that almost everything is an expression but we do have one thing that I would not consider an expression: the binding of expressions to variables. This can get confusing because there are these things called \texttt{let \textit{bindings}} and \texttt{let \textit{expressions}}. We will talk about the former first. 

A \texttt{let binding} is not an expression and just binds an expression to a variable. Here is an example:
\begin{lstlisting}[style=Myocamlstyle]
(* letBinding.ml *)
let x = 3 + 4
(* syntax *)
(* let variable = e*)
\end{lstlisting}
It is important to note that OCaml uses static and latent typing. Also recall that variables in OCaml are immutable. When we run the above code in a repl like \textit{utop} we are actually setting a top level variable which can be used to refer in other places. We ultimately want to try and avoid this to maintain more strict referential transparency so we have this expression called a \texttt{let expression}. 

A \texttt{let expression} is like setting a local variable to be used in another expression. 
\begin{lstlisting}[style=Myocamlstyle]
(* letExpression.ml *)
let x = 3 + 4 in x + 1
(* syntax *)
(* let variable = e1 in e2 *)
\end{lstlisting}
In this case, we add the \texttt{in} keyword and follow up with another expression. In this case, this is an expression so it does have a value it will evaluate to and also has a type. It's type is dependent on what the second expression's type is.
\begin{lstlisting}[style=Myocamlstyle]
(let variable = e1:t1 in e2:t2):t2
\end{lstlisting}
We can of course nest these, and since data is immutable in OCaml, variables are overshadowed. 
\begin{lstlisting}[style=Myocamlstyle]
(* scoping.ml *)
let x = 3 in let y = 4 in x + y (* 7 *)
let x = 3 in let x = 4 in x (* 4 *)
let x = 3 in let z = 4 + x in let x = 1 in x + z (* 8 *)
(* implicit parenthesis *)
let x = 3 in (let z = 4 + x in (let x = 1 in x + z))
\end{lstlisting}
Here, whenever we look consider a variable's value, it is always the closest preceding binding. 
Also, just to reiterate, these are expressions so something like the following is also possible:
\begin{lstlisting}[style=Myocamlstyle]
let x = if true then false else true in let y = 3 + 4 in let z = if true then 2 else 6 in if x then y else z
(* implicit parenthesis *)
let x = (if true then false else true) in let y = (3 + 4) in let z = (if true then 2 else 6) in (if x then y else z)
\end{lstlisting}

Now that we have an an idea of what an expression is and how to determine some basic values and types, we can build larger expressions. I think of this as analogous as taking statement variables $p$ and $p$ and then building larger statements like $p \lor q$. And since we know how to evaluate basic expressions and find out their types and values, it's like knowing the truth values of $p$ and $q$ and being able to then conclude the truth value of $p \lor q$. 

\subsection{The if Expressions}
Let us consider the very basic \texttt{if expression}. Now the \texttt{if expression} is an expression which means it has a value and type. But first let us consider it's syntax. 
\begin{lstlisting}[]
(if e1:bool then e2:t e3:t):t
\end{lstlisting}
What does this mean? As stated before, I will be using $e$ to represent expressions and $t$ for types, with $e:t$ meaing that $e$ has type $t$. So in this case, the \texttt{if expression} has an expression $e1$ which must evaluate to a \texttt{bool}, and two other expressions $e2$ and $e3$ which must \textbf{both} evaluate to the same type $t$. The \texttt{if expression}  as a whole then has that same type $t$. A little weird, let's see an example. 
\begin{lstlisting}[style=Myocamlstyle]
if true then 3 else 4
\end{lstlisting}
Here \texttt{true} is an expression of type \texttt{bool} and both \texttt{3} and \texttt{4} are expressions of type \texttt{int} which means this expression as a whole has type \texttt{int}. Now because we can substitute any valid expression for $e1,e2,e3$ as long as their types follow the above rules all the following are valid expressions:
\begin{lstlisting}[style=Myocamlstyle]
if true then 3 else 4
if true then false else true
if 3 < 4 then 5 + 6 else 7 + 8
if (if true then false else true) then (if false then 3 else 4) else (if true then 5 else 6)
\end{lstlisting}
Unlike Ruby or C, the only things that evaluate to \texttt{bool}s are \texttt{true} and \texttt{false} or expressions that evaluate to \texttt{true} and \texttt{false}. So \texttt{if 3 then 4 else 5} would be invalid. 
This idea of substituting any expression with the expected type can be used for any expression that has 'subexpressions'. So
the following are valid with \texttt{let bindings} and \texttt{let expressions}:
\begin{lstlisting}[style=Myocamlstyle]
let x = if true then false else true
let y = 3 + 4 - 10 in if true then y else y + 10
\end{lstlisting}

\subsection{Functions as Expressions}
We stated earlier that functional programming is one where we want to be able to treat functions as data. We have actually kinda saw this before. Consider the following:
\begin{lstlisting}[style=Myrubystyle]
x = 3
puts x

def x
    3
end
puts x
\end{lstlisting}
There is not much difference here as what is printed out or how we use the name \texttt{x}. In OCaml, I consider variables to be functions with no parameters that return a value very much like our \texttt{x} method above. This is because at the end of the day, if we recall out C and 216 days, a variable is just a way to refer to some specific memory address that holds data. That data could be a value, could be code. But an actual function definition looks like this:
\begin{lstlisting}[style=Myocamlstyle]
(* functions.ml *)
let area l w = l * w
(* or to use a let expression where we call the function *)
let area l w = l * w in area 2 3
(* syntax *)
(* (let name e1:t1 e2:t2 ... ex:tx = e:ty):t1 -> t2 -> tx -> ty *)
\end{lstlisting}
Similar to \texttt{let bindings} a function definition by itself is not an expression, but the variable that is bound to the function is. The type of a function is represented as a list of types that looks like \texttt{t1 -> t2 -> ... -> tx -> ty}, For example \texttt{let area l w = l * w in area} has type \texttt{int -> int -> int}. The last type in this list is always the return type, where the preceding types are the types for input. On the other hand, something like \texttt{let area l w = l * w} is not an expression but a binding of a function to variable.

The fun part is that since we know functions are expressions, and functions can take in expressions as input, then we can have functions that take in other functions. 
\begin{lstlisting}[style=Myocamlstyle]
(* functional1.ml *)
let area l w = l * w (* int -> int -> int *)
let apply f x y = f x y (* ('a -> 'b -> 'c) -> 'a -> 'b -> 'c *)
apply area 2 3
(* optional parenthesis *)
(* apply (area) (2) (3) *)
\end{lstlisting}
Now we have some new things to talk about here. Namely, what is \texttt{'a, 'b, 'c} and why is \texttt{area}'s type \texttt{int -> int -> int} and not something like \texttt{float -> float -> float}?

\subsection{Type Inference}
Let us consider the \texttt{area} function: \texttt{let area l w = l * w}. OCaml knows that this is a function with type \texttt{int -> int -> int}. Which means we cannot do something like \texttt{area 2.3 4.5}. Why is this and how does this work? 

Type inference is a way for a programming language to determine the type of a variable or value. In some languages it's real easy because you explicitly declare types: \texttt{int x = 3;}. In OCaml, variables types are determined by the operations or syntax of the expression. So just like you can only use things like \texttt{\&\&} and \texttt{||} on \texttt{bool}s, we can only use things like \texttt{+,-,*,/} on \texttt{int}s. If you wanted to do operations on \texttt{float}s then you need to use different operators. See the following:
\begin{lstlisting}[style=Myocamlstyle]
(* operations.ml *)
2 + 3 (* int and int *)
1.3 +. 4.3 (* float and float *)
"hello" ^ " world" (* string and string *)
true || false (* bool and bool *)
int_of_char 'a' (* char input, int output *)
2 + 3.0 (* error *)
3 ^ 4 (* error *)
\end{lstlisting}
Some operators however, work on many different types. One such example is the \texttt{>} (greater than) operator. This operator along with \texttt{<, >=, <=, =} all can take in any two inputs as long as those two inputs are the same type. The output will always be of type \texttt{bool}.
\begin{lstlisting}[style=Myocamlstyle]
(* compare.ml *)
2 > 4 (* false *)
"hello" <= "world" (* true *)
true = false (* false *)
\end{lstlisting}
One thing to note is that we use \texttt{=} for testing equality since we bind variables with \texttt{let ... = e}. So we can say something like \texttt{let x = 2 = 3} and OCaml knows that \texttt{x} is the varaible and anything after the first \texttt{=} sign is the expression. 
Anyway, this is important because then what type is inferred from a function like
\begin{lstlisting}[style=Myocamlstyle]
(* typeInference0.ml *)
let compare x y = x > y
\end{lstlisting}
Here we have no idea what type \texttt{x} and \texttt{y} have to be. In this case, OCaml uses a special type notation. The type of \texttt{compare} is \texttt{'a -> 'a -> bool}. That is, we have two inputs which must both be the same type, and we know the result will be of type \texttt{bool}. If we are given something even stranger like: 
\begin{lstlisting}[style=Myocamlstyle]
(* typeInference1.ml *)
let f x y = 3
(* this is equivalent to something like 
def f(x,y)
    3
end
*)
\end{lstlisting}
OCaml will give this function type \texttt{'a -> 'b -> int}. We are returning an \texttt{int} but the input types could be anything. Since the input types don't even need to be the same type here, we give them different symbols. 
So let's go back to our \texttt{apply} function and break it's type down again.
\begin{lstlisting}[style=Myocamlstyle]
(* typeInference2.ml *)
let apply f x y = f x y  (* ('a -> 'b -> 'c) -> 'a -> 'b -> 'c *)
\end{lstlisting}
First let's list out the parameter names: \texttt{f, x, y}. The first parameter is a function which has two inputs of unknown type. We also don't know if the two inputs have to be the same or different. At this moment we know that the function's type
is \texttt{'a -> 'b -> ?}. Looking at the function we are given no information about what the return type of \texttt{f} is so
we give it yet a another symbol. Thus we can say that the type of \texttt{f} is \texttt{'a -> 'b -> 'c}. Now we know that \texttt{f} is being called on parameters \texttt{x} and \texttt{y} so we know that \texttt{x} must be the type of \texttt{f}'s first argument so we can give \texttt{x} type \texttt{'a}. We then know that \texttt{y} is being used as \texttt{f}'s second
argument so it should be of type \texttt{'b}. So at this point we know the type of \texttt{apply} is 
\texttt{('a -> 'b -> 'c) -> 'a -> 'b -> ?} (we put any function's type in parenthesis to show it's a function). Lastly we know that the returned value of \texttt{apply} is whatever \texttt{f x y} returns. Since we know that \texttt{f} returns some value of type \texttt{'c}, we can
say \texttt{apply}'s return type is also \texttt{'c}. Thus the entire type of \texttt{apply} is \texttt{('a -> 'b -> 'c) -> 'a -> b -> 'c}

\section{Ocaml Pattern Matching}

The next feature that OCaml allows us to have is the ability to pattern match. Pattern matching is, if you squint, very closely related to a \texttt{switch} statement. While I could show you pattern matching with what we know, I find it easier to demonstrate once we know OCaml's built in data structure: \texttt{list}s. 

\subsection{Lists}
In other languages you may used to having these data structures called Arrays. In OCaml we don't have arrays, we what we have instead is \texttt{lists}. Let's first see the syntax:
\begin{lstlisting}[style=Myocamlstyle]
(* list.ml*)
[1;2;3;4] (* type: int list *)
(* syntax *)
(* [e1:t; e2:t; ... ex:t]*)
\end{lstlisting}
Looks a little like an Array but instead of being comma delimited, it is semi-colon delimited. Looking at the syntax we can also conclude that the \texttt{list}s must be homogeneous. Additionally, we can see that we do not need to put values, but rather we can put expressions. Here are some examples of other lists
\begin{lstlisting}[style=Myocamlstyle]
(* list1.ml*)
[1;2;3;4] (* int list *)
[2.3;1.0] (* float list *)
["hello", "World"] (* string list *)
[2 + 3; 4-4; 7 * 9] (* int list *)
let f1 x = x + 1 in let f2 y = x + 1 in let f3 z = z + 1 in [f1;f2;f3] (* (int -> int) list *)
\end{lstlisting}
The last one is a list of \texttt{int -> int} functions, wild huh? Now it is important to note that \texttt{list}s are implemented as a linked list under the hood which means they are recursive.

\subsection{Recursion}
Now you may have noticed that I have not talked about \texttt{for, while, do while} or any other type of looping structure. That is because it does not exist in OCaml. We have something better: recursion. In OCaml, data structures are recursive and to do looping, we need to make recursive functions. We will talk about this is a bit. We first need to talk about lists. Now since \texttt{list}s are recursive, we need to consider how to define a \texttt{list}. If you recall from 132 your linked list data structure, you should recall that a linked list in Java is a 'node' which contains a piece of data and then points to another list or null. In OCaml, we don't use these words, but they can be used analogously. 
In OCaml we don't point to Null, but instead we point to an empty \texttt{list} which we call \texttt{Nil}. 
We then have an element which points to the rest of the list, which we use what we call the \texttt{Cons} operator. 
\begin{lstlisting}[style=Myocamlstyle]
[] (* Nil, the empty list *)
1 :: [] (* 1 cons Nil, add 1 to the empty list. Evaluates to [1] *)
1 :: 2 :: [] (* 1 cons 2 cons NIL. Evaluates to [1;2] *)
1 :: [2] (* 1 cons list of 2. Evaluates to [1;2] *)
(* syntax *)
(* e1:t :: e2:t list *)
\end{lstlisting}
Notice that the syntax shows that we are using expressions which means we have some wierd expressions that represent \texttt{list}s. Also note that the \texttt{cons} operator's left hand operator is of type \texttt{t} and the right hand operator must be of type \texttt{t list}. 
\begin{lstlisting}[style=Myocamlstyle]
[2 + 3; 4 - 5] (* int list. Evaluates to [5;-1] *)
[if true then false else true; false;] (* bool list. Evaluates to [false;false] *)
[[1;2;3];[4;5;6]] (* int list list. Is a value *)
[print_string "hello"; print_string "world"] (* Unit List. Don't worry about Unit now, but notice that "worldhello" is printed. *)
\end{lstlisting}
Notice that when we put expressions into lists, they are evaluated and not stored as expressions, but also evaluated from right to left order (see the last example). 

\subsection{Pattern Matching}

So now that we have an idea of what a \texttt{list} is and how to construct one, now we have to learn how to deconstruct a \texttt{list}. Pattern matching is the way to deconstruct any data structure in OCaml and is a language feature not found in all languages. In order to pattern match, we need to learn a new expression: the \texttt{match} expression. 
\begin{lstlisting}[style=Myocamlstyle]
let x = 5
match x with 
    0 -> 0
    |1 -> 1
    |3 -> 2
    |5 -> 3
    |_ -> 4
(* Syntax *)
(* (match e1:t1 with
     pattern1 -> e2:t2
    |pattern2 -> e3:t2
    | ...   ):t2
\end{lstlisting}
A \texttt{match} expression takes in an expression/value and then checks to see if it has the same structure as any of the cases. If it matches with a case, it will then preform the expression linked to the case. The last line is an underscore, which is used as a wildcard (match with anything else). Here is an analogous switch statement:
\begin{lstlisting}
switch(5){
    case(0): return 0;
    case(1): return 1;
    case(3): return 2;
    case(5): return 3;
    default: return 4;
}
\end{lstlisting}
I don't want you to think of them as the same though, and pattern matching can do a lot more than a switch statement so just use this vaguely related but not the same. However like a switch statement, a match statement will check until the first pattern that satisfies the requirements and then not look at any of the other patterns. Additionally, notice the match expression is an expression which means it can be evaluated to a value and has a type. It's type is whatever each case returns, and so we need each branch to have the same return type. 
The next thing to discuss is the idea of a \textit{pattern}. A pattern is not like a regular expression pattern, but it matches with how a piece of data could be represented. Consider all the ways we can represent a list of 2 items. We can use each of these in a math expression and they mean the same thing. 
\begin{lstlisting}[style=Myocamlstyle]
match [1;2] with
    a::b::[] -> 0
    |a::[b] -> 1
    |[a;b] -> 2
\end{lstlisting}
In the above example, the expression evaluates to \texttt{0}, but all of those patterns mean the same thing. Here is an example of pattern matching on a list where we return the length or 4 if longer than 3 elements.
\begin{lstlisting}[style=Myocamlstyle]
(*let lst = ... some list *)
match lst with
    [] -> 0
    |[a] -> 1
    |a::b::[] -> 2
    |a::[b;c] -> 3
    |h::t -> 4
\end{lstlisting}
In this example we are matching some previously defined list named \texttt{lst} and seeing if the structure is anything like what we have on lines \texttt{3-7}. If we take a look at line 7, we will see this pattern \texttt{h::t}. Remember our syntax of a list: \texttt{e1:t :: e2:t list}. This pattern is just a single value cons to some list of some arbitrary size. Ultimately, as long as a list's size is greater than 1, this pattern would match, but since it's the last item, it will only be reached if the preceding patterns do not match.

\subsection{Recursive Functions}
Knowing all this, we can then make functions that find the head of a list, or the last item of a list, but first remember what I said earlier, there is no looping construct except recursion. So we need to make recursive functions. 
To make a recursive function is the same as how we construct any other function but we need the \texttt{rec} keyword. Let's unalive 2 creatures with 1 weapon:
\begin{lstlisting}[style=Myocamlstyle]
(* Assume the list cannot be empty *)
let rec tail lst = match lst with
    [x] -> x
    |_::t -> tail t
\end{lstlisting}
First, notice a recursive function is similar to a normal function. We just need the \texttt{rec} keyword after the \texttt{let} keyword. Next, let's consider the patterns I used. If we assume the list is not empty, then the base case is a list with 1 item. In this case, just return that 1 item. Otherwise, if the list takes the form of \texttt{\_::t}, or something cons list, then just recursively call \texttt{tail} on the rest of the list. Notice that since I did not need the head item, I did not need to bind it to a variable, so I could just use the wildcard character. 
Another recursive function example: sum up the values in an \texttt{int list}.
\begin{lstlisting}[style=Myocamlstyle]
let rec sum lst = match lst with
    [] -> 0
    |h::t -> h + sum t
\end{lstlisting}
There are other data types that exist besides lists which you can use and pattern match on. Please refer to the Data Types and Syntax section for more (Section \ref{sec:data_type}). 

\section{Data Types and Syntax}\label{sec:data_type}
\subsection{Data Types}
\subsubsection{Basic Types}
\subsubsection{Data Structures}
There are 4 main data structures that exist in OCaml. They are 
\begin{itemize}
    \item Lists
    \item Tuples
    \item Variants
    \item Records
\end{itemize}.
Each one of these things can be pattern matched and used to construct more complicated data structures. However in my experience I have rarely ever used records. 

I talked about lists in an earlier section of this chapter so you can refer there for more info but here are some examples.
\begin{lstlisting}[style=Myocamlstyle]
[1;2;3] (* int list*)
[] (* empty list, Nil, 'a lst *)
[2.0 +. 3.4] (* float list *)
let f x = x + 1 in let g y = y * 1 in [f;g] (* (int -> int) list *)
\end{lstlisting}

Now that we are refreshed on \texttt{list}s, let's talk about tuples. Tuples are ways for us to package data together to be a single 'value' so to speak. This can be useful since functions can only have one return value, so if we need to return multiple pieces of data, a tuple could be the way to go. But enough talking, here is an example:
\begin{lstlisting}[style=Myocamlstyle]
(* tuples.ml *)
(3,4) (* int * int *)
(1,2,"hello") (* int * int * string *)
(* syntax *)
(* (e1:t1,e2:t2,...,ex:tx):t1 * t2 * ... tx *)
\end{lstlisting}
As you can see tuples are just expressions that comma delimited and placed in parenthesis. Some important things to note is that tuples are of fixed size and their type is dependent on the size and types of the subexpressions. For example, \texttt{(3,2)} is an \texttt{int * int} tuple which is different than \texttt{3,2,1)} which is an \texttt{int * int * int} tuple. We can pattern match to break apart tuples by using our match expression. 
\begin{lstlisting}[style=Myocamlstyle]
(* tuple-match.ml *)
let t = (1,2)
match t with 
|(0,0) -> 0
|(1,1) -> 1
|(1,b) -> b + b
|(a,b) -> a * b
\end{lstlisting}

The next data type we can talk about are variants. These are similar but not the same as enums. They are ways we can give names and make our own types in OCaml. 
\begin{lstlisting}[style=Myocamlstyle]
(* variants.ml *)
type coin = HEADS | TAILS
let x = HEADS (* type is coin, value is HEADS *)
\end{lstlisting}
These types are then recognized by the rest of OCaml and we can write functions based on these types. To figure out what type you are using, you can use pattern matching.
\begin{lstlisting}[style=Myocamlstyle]
(* variants.ml *)
type coin = HEADS | TAILS
let flip c = match c with HEADS -> TAILS | TAILS -> HEADS
(* flip is a function of type coin -> coin *)
type parity = Even | Odd
let is_even p = match p with Even -> true | Odd -> false
(* is_even is a function of type parity -> bool *)
\end{lstlisting}
These variants are helpful for just renaming or making data values look pretty. For each of these examples we could have just used bools or ints to represent data. However, variants also allow us to store data in our custom types. Consider the following:
\begin{lstlisting}[style=Myocamlstyle]
(* variants.ml *)
type shape = Rect of int * int | Circle of float
let r = Rect 3 4 (* type is shape, value is Rect(3,4) *)
let c = Circle 4.0 (* type is shape, value is Circle(4.0) *)
\end{lstlisting}
Here I am saying to make a shape type and that shapes can either be \texttt{Rects} which hold \texttt{int * int} tuple information, or \texttt{Circle}s which hold \texttt{float}s. We can pattern match to figure out what type we are talking about, and to pull out information.  
\begin{lstlisting}[style=Myocamlstyle]
(* variants.ml *)
type shape = Rect of int * int | Circle of float
let r = Rect 3 4 (* type is shape, value is Rect(3,4) *)
let c = Circle 4.0 (* type is shape, value is Circle(4.0) *)
let area s = match s with 
Rect(l,w) -> float_of_int l * w (* need to cast this to float so return types match *)
|Circle(r) -> r * r * 3.14
\end{lstlisting}
This is useful if we want to make Trees or our own lists. 
\begin{lstlisting}[style=Myocamlstyle]
(* variants.ml *)
type int_tree = Node of int * int_tree * int_tree | Leaf
let t = Node(4,Node(3,Node(2,Leaf,Leaf),Leaf),Node(5,Leaf,Leaf))
(* tree that looks like 
    4
   / \
  3   5
 /
2
*)
\end{lstlisting}
\subsection{Syntax}
\end{document}
